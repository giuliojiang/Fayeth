%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 3.1 (25/3/14)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Linux and Unix Users Group at Virginia Tech Wiki 
% (https://vtluug.org/wiki/Example_LaTeX_chem_lab_report)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage[version=3]{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 

\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)

%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Fayeth \\ DIMACS Fuzzer} % Title

\author{Giulio Jiang \\ Abraao Mota \\ Domenico Marino} % Author name

\date{\today} % Date for the report

\begin{document}

\maketitle % Insert the title, author and date

\begin{center}
\begin{tabular}{l r}
Imperial College London \\
Department of Computing \\
\end{tabular}
\end{center}

% If you wish to include an abstract, uncomment the lines below
% \begin{abstract}
% Abstract text
% \end{abstract}

\newpage



\section{Introduction}

Fayeth is a fuzzer targeted to boolean satisfiability solvers. It can generate and mutate 
random inputs and attempt to trigger bugs in the System Under Test (SUT), or create CNF files 
that maximize the total code coverage of the software.

\section{Overview}

Fayeth is implemented in Java, and it can be executed in two different modes: 
Undefined Behaviour Mode and Functional Error Mode. The model of operation is simple: 
once started, Fayeth will automatically generate test cases and evaluate their 
effectiveness on the target SAT solver. The fuzzer can be stopped at any time, 
and the output directories will contain the generated inputs that Fayeth considers 
the most interesting.

\section{Undefined Behaviour Mode}

The Undefined Behaviour Mode is aimed at finding undefined behaviour bugs, crashes and timeouts in the
SAT Solver being targeted. It generates automatically random inputs of different kinds,
and observes the behaviour of the SUT to try to detect whether some bug has manifested itself.
The Undefined Behaviour Mode's detection power is amplified by the use of the Address
Sanitizer to compile the SAT Solver, giving Fayeth the ability to detect a wider range of
potentially silent bugs.\\

Fayeth can generate a range of inputs, which we can categorize as follows:

\begin{itemize}

		\item \verb|Random string| - A completely random sequence of characters, with an extremely low probability of representing a valid \texttt{DIMACS} file. This strategy helps to catch undefined behaviour happening during parsing.
		The length of the random string is not fixed and the strings generated contain any of the characters encoded in the first 8 bits of \texttt{UTF-8}, from \texttt{0} to \texttt{U+007F}. \\
		This is a good example of dumb fuzzing.
		
		\item \verb|Random DIMACS-like string| - A partially random string, resembling the structure of \texttt{DIMACS}. all of the 
		files generated start with \texttt{p cnf number1 number2}, where \texttt{number1} and \texttt{number2} are two random numbers
		and the rest of the file is composed of random integers (separated by space like \texttt{DIMACS}) and each line ends with a \texttt{0}, again like \texttt{DIMACS}. \\
		This strategy has the potential of causing overflows, as the \texttt{SUT} may allocate enough space for the data structure according to the \texttt{DIMACS} header, but the clauses and variables effectively created do not match the numbers specified in the header.\\
		This is an example of smart fuzzing.
		
		\item \verb|Random Valid DIMACS| - A randomly generated \texttt{DIMACS} file, with reasonably large formulae, this strategy generates files that are perfectly valid \texttt{DIMACS}, but being relatively large aim at catching infinite loops or stack overflows. \\
		This is an example of smart fuzzing.
		
		\item \verb|Random Broken DIMACS| - A mix of the \emph{Random strings} and the \emph{Random DIMACS-like string} strategies.
		This strategy generates a file that contains a valid \texttt{DIMACS} header like \texttt{p cnf number1 number2}, where \texttt{number1} and \texttt{number2} are two random numbers, followed by random \texttt{UTF-8} characters.
		This strategy aims to find bugs related to overflow and bad input sanitization.  \\
		This is technically smart fuzzing, but is closer to a dumb one in practice.

\end{itemize}

\subsection{Strategies}

\subsection{}

\section{Functional Error Mode}

The functional Error Mode is aimed at generating CNF formulas that maximize the code coverage of the SUT. 
It does so by taking as input a collection of existing formulas, which are mutated iteratively by a 
various set of strategies.\\

The code coverage tool \verb|gcov| is used to create a feedback loop between the fuzzer and the SAT solver.
The fuzzer not only generates formulas for each given input, but will also run the solver to evaluate
their effectiveness, which is taken into consideration for further transformations.

\subsection{Strategies}

We have implemented several different strategies, each specialized in a different kind of transformation.
Some transformations produce equivalent formulas, while others can inject additional clauses or literals
and potentially make the formula unsatisfiable. \\

Strategies are chosen at random during runtime, and each can work on top of the results generated by the
previous strategies, allowing us to effectively combine multiple transformations. \\

\begin{itemize}

\item \verb|Additional unsatisfiable clauses| - The strategy has a database of small unsatisfiable formulas.
Given the formula to be transformed, the strategy will choose a set of unused variables, pick a random
unsatisfiable formula from the database, and rename each of the variables to unused variables. The resulting
clauses are injected in the input formula, which has then its clauses shuffled.
This strategy will make any formula unsatisfiable as the conjunction of anything with a set of unsatisfiable
clauses will always be false.

\end{itemize}


\section{Optimizations}

\section{Evaluation}

During development, we have tested our fuzzer against four different SAT solvers: our own solver, \verb|Banosat|, and
the three other solvers that were provided. After running some tests on each of them, we reached the following conclusions.

\subsection{Banosat}



\subsection{Sample solver 1}

\subsection{Sample solver 2}

\subsection{Sample solver 3}



\end{document}

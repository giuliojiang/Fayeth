%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 3.1 (25/3/14)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Linux and Unix Users Group at Virginia Tech Wiki 
% (https://vtluug.org/wiki/Example_LaTeX_chem_lab_report)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{graphicx} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage{float}


\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)

%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Fayeth \\ DIMACS Fuzzer} % Title

\author{Giulio Jiang \\ Abraao Mota \\ Domenico Marino} % Author name

\date{\today} % Date for the report

\begin{document}

\maketitle % Insert the title, author and date

\begin{center}
\begin{tabular}{l r}
Imperial College London \\
Department of Computing \\
\end{tabular}
\end{center}

% If you wish to include an abstract, uncomment the lines below
% \begin{abstract}
% Abstract text
% \end{abstract}

\newpage



\section{Introduction}

Fayeth is a fuzzer targeted to boolean satisfiability solvers. It can generate and mutate 
random inputs and attempt to trigger bugs in the System Under Test (SUT), or create CNF files 
that maximize the total code coverage of the software.

\section{Overview}

Fayeth is implemented in Java, and it can be executed in two different modes: 
Undefined Behaviour Mode and Functional Error Mode. The model of operation is simple: 
once started, Fayeth will automatically generate test cases and evaluate their 
effectiveness on the target SAT solver. The fuzzer can be stopped at any time, 
and the output directories will contain the generated inputs that Fayeth considers 
the most interesting.

\section{Undefined Behaviour Mode}

The Undefined Behaviour Mode is aimed at finding undefined behaviour bugs, crashes and timeouts in the
SAT Solver being targeted. It generates automatically random inputs of different kinds,
and observes the behaviour of the SUT to try to detect whether some bug has manifested itself.
The Undefined Behaviour Mode's detection power is amplified by the use of the Address
Sanitizer to compile the SAT Solver, giving Fayeth the ability to detect a wider range of
potentially silent bugs.\\

Fayeth can generate a range of inputs, which we can categorize as follows:

\begin{itemize}

		\item \verb|Random string| - A completely random sequence of characters, with an extremely low probability of representing a valid \texttt{DIMACS} file. This strategy helps to catch undefined behaviour happening during parsing.
		The length of the random string is not fixed and the strings generated contain any of the characters encoded in the first 8 bits of \texttt{UTF-8}, from \texttt{0} to \texttt{U+007F}. This is a good example of dumb fuzzing.
%		See figure \ref{fig:random-string} for reference.
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\linewidth]{"random string"}
			\caption{A snippet of a file generated by our \texttt{Random string} strategy.}
			\label{fig:random-string}
		\end{figure}
		
		\item \verb|Random DIMACS-like string| - A partially random string, resembling the structure of \texttt{DIMACS}. all of the 
		files generated start with \texttt{p cnf number1 number2}, where \texttt{number1} and \texttt{number2} are two random numbers
		and the rest of the file is composed of random integers (separated by space like \texttt{DIMACS}) and each line ends with a \texttt{0}, again like \texttt{DIMACS}. 
		This strategy has the potential of causing overflows, as the \texttt{SUT} may allocate enough space for the data structure according to the \texttt{DIMACS} header, but the clauses and variables effectively created do not match the numbers specified in the header.
		This is an example of smart fuzzing.
%		See figure \ref{fig:random-dimacs-like} for reference.
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.8\linewidth]{"random semi dimacs"}
			\caption{A snippet of a file generated by our \texttt{Random DIMACS-like string} strategy, the \texttt{DIMACS} header at the top has no relation with the rest of the file, The number of variables in the \texttt{DIMACS} header (4) does not match the real number of variables.}
			\label{fig:random-dimacs-like}
		\end{figure}
		
		\item \verb|Random Valid DIMACS| - A randomly generated \texttt{DIMACS} file, with reasonably large formulae, this strategy generates files that are perfectly valid \texttt{DIMACS}, but being relatively large aim at catching infinite loops or stack overflows.
		This is an example of smart fuzzing.
%		See figure \ref{fig:random-dimacs} for reference.
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.8\linewidth]{"random valid dimacs"}
			\caption{A snippet of a file generated by our \texttt{Random valid DIMACS} strategy, the \texttt{DIMACS} header is generated according to the real number of clauses and variables, the number of clauses and the number of variables is reasonably large.}
			\label{fig:random-dimacs}
		\end{figure}
	
		\item \verb|Random Broken DIMACS| - A mix of the \emph{Random strings} and the \emph{Random DIMACS-like string} strategies.
		This strategy generates a file that contains a valid \texttt{DIMACS} header like \texttt{p cnf number1 number2}, where \texttt{number1} and \texttt{number2} are two random numbers, followed by random \texttt{UTF-8} characters.
		This strategy aims to find bugs related to overflow and bad input sanitization. 
		This is technically smart fuzzing, but is closer to a dumb one in practice.
		%See figure \ref{fig:random-broken-dimacs} for reference.
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.8\linewidth]{"random broken dimacs"}
			\caption{An snippet of a file generated by our \texttt{Random Broken DIMACS} strategy, the \texttt{DIMACS} header at the top has no relation with the rest of the file.}
			\label{fig:random-broken-dimacs}
		\end{figure}

\end{itemize}








\section{Functional Error Mode}

The functional Error Mode is aimed at generating CNF formulas that maximize the code coverage of the SUT. 
It does so by taking as input a collection of existing formulas, which are mutated iteratively by a 
various set of strategies.

The code coverage tool \verb|gcov| is used to create a feedback loop between the fuzzer and the SAT solver.
The fuzzer not only generates formulas for each given input, but will also run the solver to evaluate
their effectiveness, which is taken into consideration for further transformations.

\subsection{Strategies}

We have implemented several different strategies, each specialized in a different kind of transformation.
Some transformations produce equivalent formulas, while others can inject additional clauses or literals
and potentially make the formula unsatisfiable.
Strategies are chosen at random during runtime, and each can work on top of the results generated by the
previous strategies, allowing us to effectively combine multiple transformations. 

\begin{itemize}

\item \verb|Shuffling existing variables| - This strategy aimed to test the SUT by simply changing existing CNF clauses Tby shuffling the literals contained within each clause given by the CNF. This strategy should clearly have no expected change in the satisfiability of the resulting CNF (SAT $\rightarrow$ SAT, UNSAT $\rightarrow$ UNSAT), but tested whether the SAT solver in question would behave differently with reorganised clauses. It is a simple strategy, but ensures we cover any cases of weird SUT behaviour.

\item \verb|Shuffling existing clauses| - Similarly to the strategy above, this strategy shuffles the existing clauses in the CNF. Again, this shouldn't change the satisfiability of the resulting CNF produced. It is a very simple strategy, but is useful in identifying any serious unexpected behaviour by the SUT - switching clauses inputted to the SAT solver should not change the underlying behaviour. 

\item \verb|Insert Pure Literals| - Inserting pure literals involved creating a new unused variable in the CNF, assigning its literal value (+1 / -1) according to a random boolean, and injecting several copies of this new literal in a random number of clauses in our CNF. As this injects a pure literal, the expected satisfiability of the generated CNF also doesn't change - if it was UNSAT before, adding these will not change that. Since pure literals can be assigned a value regardless of the rest of the clause or formula, this will also maintain any SAT CNF's as SAT.

\item \verb|Additional unsatisfiable clauses| - The strategy has a database of small unsatisfiable formulas.
Given the formula to be transformed, the strategy will choose a set of unused variables, pick a random
unsatisfiable formula from the database, and rename each of the variables to unused variables. The resulting
clauses are injected in the input formula, which has then its clauses shuffled.
This strategy will make any formula unsatisfiable as the conjunction of anything with a set of unsatisfiable
clauses will always be false.

\item \verb|Insert Unit Clauses| - In an attempt to trigger BCP algorithms in SAT solvers that rely on unit clauses,
this strategy can randomly select an existing clause and add to it a new negated literal with a variable that did
not appear in the formula, and a new clause containing only the new literal. This implies that the new
literal has to be True for the formula to be satisfiable, which makes the literal injected in the existing
clause false. Therefore the original clause has still the same logical meaning as before, and this transformation
creates an equisatisfiable mutation.

\end{itemize}


\section{Optimizations}

Fayeth is able to run in multithreaded mode in Undefined Behaviour mode (this is ran by default, to disable multithreading we pass a \texttt{--no-threading} flag as an argument). Each task is run independently
and outputs are collected by a thread-safe collector service. On a multithreaded machine, this optimization
yields a linear increase in fuzzing rate with the number of cores available. However, this comes at a cost - we cannot guarantee result reproducibility in multi-threading mode even when passing the same seed to the program.\\

Unfortunately, due to the dependency on \verb|gcov| to obtain coverage data, the Functional Bug Mode cannot
easily exploit multi-threading unless multiple copies of the SUT are made to ensure that coverage data does
not get overwritten by concurrent copies of the solver. In our limited time available, we did not implement
multithreading for the Functional mode, but this would be a further optimisation to enable in the future.

\section{Evaluation}

During development, we have tested our fuzzer against four different SAT solvers: our own solver, \verb|Banosat|, and
the three other solvers that were provided.  \\

As we are the authors of Banosat, we had an overall idea of where the bugs could be found, 
including the voluntarily added undefined behaviour and functional bugs that were part of the first submission.\\

We were reasonably confident that we had a robust parser. However, running Fayeth in UB mode on
Banosat resulted immediately in a number of program crashes, illegal memory accesses and buffer overflows
that we did not know about. Many of the mistakes were avoidable although hard to see without having
a testable input, and the fact that Fayeth allowed us to discover bugs that we were not aware of is
a good indication that the fuzzer, despite its simplicity, can be effective. \\

For example, Banosat was not able to recognize the case where the header of a CNF file was malformed or missing,
as it was actually not checking that the header appeared at the beginning of the file. While this bug
does not cause any issue when parsing well-formed formulas, it does cause segmentation faults when parsing
a random string. A graceful exit with an error message would have been a better behaviour.
Additionally, the integer parser was not able to detect parse errors in literals. Inputs generated
by \verb|Random Broken DIMACS Strategy| were therefore very likely to trigger bugs in our software. \\

We have also checked that the undefined behaviour bug we have introduced (a use-after-free that occurred with certain
inputs) was being correctly triggered and identified by the Undefined Behaviour Mode. \\

Our fuzzer was able to trigger undefined behaviour in all of the other solvers as well, and our \texttt{Random Broken DIMACS Strategy} was particularly successful in causing UB's - namely Segmentation Faults with exit code 139 and heap buffer overflows (which were detected by ASan). Additionally, we also found several cases that caused non-zero exit codes (exit code 1 and 23 were the most frequent occurrences). \\

The \texttt{func} mode of our fuzzer also worked towards improving coverage based on the \texttt{gcov} feedback loop. As a result, we generated results with some measure of success. We performed best on \texttt{solver2}, where we obtained a maximum coverage of 83\%, and 66\% coverage in our worst performing SUT, \texttt{solver3}. \texttt{Banosat} and \texttt{solver1} got 76\% and 70\% coverage, correspondingly.  \\

This coverage is limited by how exploratory our \texttt{func} mode strategies were. Due to the time limitations of the project, the strategies we implemented did not explore very interesting metamorphic relations of the CNF formulas. These were unlikely to produce any different, interest behaviour from the SUT's, and thus not have very high coverage, even when combined with each other.



\end{document}
